# -*- coding: utf-8 -*-
"""NNCelsius2Fahrenheit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18BW3TMnJQC5XLhrmQ4-QfXNvDjkMHxLJ

Create a neural network that can convert Celsius to Fahrenheit and examine the weights.
- Using `TensorFlow` and `Keras` build a single layered network with a single input and a single output and a single neuron.
- Using `NumPy` generate ~20 input/output values to test
- Train the neural network on your data.
- Test the neural network to see if it is working.
- Examine the weights to see if they match $F = C \times 1.8 + 32$.
"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import tensorflow as tf

# generate 1000 random numbers representing degrees in celcium between 0 and 100
train_data = np.random.random(1000) * 100
noise = (np.random.random(1000) - 0.5) * 100
# generate corresponging Fehrenheit values
train_targets = train_data*1.8 + 32 + noise
plt.plot(train_data, train_targets, '.')

from keras import models
from keras import layers
network = models.Sequential()
network.add(layers.Dense(1))
network.compile(optimizer=tf.keras.optimizers.Adam(.1), loss='mean_squared_error')

history = network.fit(train_data, train_targets, epochs=50, verbose=False)

plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.plot(history.history['loss'])

print('5 * 1.8 + 32 = 41')
print(network.predict([5]))
print('99 * 1.8 + 32 = 210.2')
print(network.predict([99]))

print("This is the weight that should be pretty close to the *1.8 in the formula: {}".format( network.layers[0].get_weights()[0][0] ))
print("This is the bias that should be pretty close to the +32 in the formula: {}".format( network.layers[0].get_weights()[1] ))

